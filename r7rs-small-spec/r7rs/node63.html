---
title: Equivalence predicates
nav_next: node64.html
nav_next_lbl: Numbers
nav_up: node62.html
nav_up_lbl: Standard procedures
nav_prev: node62.html
nav_prev_lbl: Standard procedures
nav_contents: node3.html
nav_contents_lbl: Contents
nav_index: node106.html
nav_index_lbl: Index
---
{% include head.html %}

<BODY >

{% include nav.html %}

<H1>
{{ page.title }}
</H1>
<P>
A predicate is a procedure that always returns a boolean
value (#t or #f). An equivalence predicate is the computational
analogue of a mathematical equivalence relation;
it is symmetric, re
exive, and transitive. Of the equivalence
predicates described in this section, eq? is the finest
or most discriminating, equal? is the coarsest, and eqv?
is slightly less discriminating than eq?.
(eqv? obj1 obj2) procedure
The eqv? procedure defines a useful equivalence relation on
objects. Brie
y, it returns #t if obj1 and obj2 are normally
regarded as the same object. This relation is left slightly
open to interpretation, but the following partial specification
of eqv? holds for all implementations of Scheme.
The eqv? procedure returns #t if:

obj1 and obj2 are both #t or both #f.

obj1 and obj2 are both symbols and are the same symbol
according to the symbol=? procedure (section 6.5).

obj1 and obj2 are both exact numbers and are numerically
equal (in the sense of ==&gt;.

obj1 and obj2 are both inexact numbers such that they
are numerically equal (in the sense of ==&gt; and they yield
the same results (in the sense of eqv?) when passed as
arguments to any other procedure that can be defined
as a finite composition of Scheme's standard arithmetic
procedures, provided it does not result in a NaN
value.

obj1 and obj2 are both characters and are the same
character according to the char=? procedure (section
6.6).

obj1 and obj2 are both the empty list.

obj1 and obj2 are pairs, vectors, bytevectors, records,
or strings that denote the same location in the store
(section 3.4).

obj1 and obj2 are procedures whose location tags are
equal (section 4.1.4).
The eqv? procedure returns #f if:

obj1 and obj2 are of diㄦent types (section 3.2).

one of obj1 and obj2 is #t but the other is #f.

obj1 and obj2 are symbols but are not the same symbol
according to the symbol=? procedure (section 6.5).

one of obj1 and obj2 is an exact number but the other
is an inexact number.

obj1 and obj2 are both exact numbers and are numerically
unequal (in the sense of ==&gt;.
{obj1 and obj2 are both inexact numbers such that either
they are numerically unequal (in the sense of ==&gt;,
or they do not yield the same results (in the sense
of eqv?) when passed as arguments to any other procedure
that can be defined as a finite composition of
Scheme's standard arithmetic procedures, provided it
does not result in a NaN value. As an exception, the
behavior of eqv? is unspecified when both obj1 and
obj2 are NaN.
%obj1 and obj2 are characters for which the char=? procedure
returns #f.
 one of obj1 and obj2 is the empty list but the other is
not.
iobj1 and obj2 are pairs, vectors, bytevectors, records,
or strings that denote distinct locations.
nobj1 and obj2 are procedures that would behave differently
(return diㄦent values or have diㄦent side
ects) for some arguments.
6. Standard procedures 31
(eqv? 'a 'a) ==&gt; #t
(eqv? 'a 'b) ==&gt; #f
(eqv? 2 2) ==&gt; #t
(eqv? 2 2.0) ==&gt; #f
(eqv? '() '()) ==&gt; #t
(eqv? 100000000 100000000) ==&gt; #t
(eqv? 0.0 +nan.0) ==&gt; #f
(eqv? (cons 1 2) (cons 1 2))==&gt; #f
(eqv? (lambda () 1)
(lambda () 2)) ==&gt; #f
(let ((p (lambda (x) x)))
(eqv? p p)) ==&gt; #t
(eqv? #f 'nil) ==&gt; #f
The following examples illustrate cases in which the above
rules do not fully specify the behavior of eqv?. All that
can be said about such cases is that the value returned by
eqv? must be a boolean.
(eqv? "" "") ==&gt; unspecified
(eqv? '#() '#()) ==&gt; unspecified
(eqv? (lambda (x) x)
(lambda (x) x)) ==&gt; unspecified
(eqv? (lambda (x) x)
(lambda (y) y)) ==&gt; unspecified
(eqv? 1.0e0 1.0f0) ==&gt; unspecified
(eqv? +nan.0 +nan.0) ==&gt; unspecified
Note that (eqv? 0.0 -0.0) will return #f if negative zero
is distinguished, and #t if negative zero is not distinguished.
The next set of examples shows the use of eqv? with procedures
that have local state. The gen-counter procedure
must return a distinct procedure every time, since each
procedure has its own internal counter. The gen-loser
procedure, however, returns operationally equivalent procedures
each time, since the local state does not act the
value or side ects of the procedures. However, eqv? may
or may not detect this equivalence.
(define gen-counter
(lambda ()
(let ((n 0))
(lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
(eqv? g g)) ==&gt; #t
(eqv? (gen-counter) (gen-counter))
==&gt; #f
(define gen-loser
(lambda ()
(let ((n 0))
(lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
(eqv? g g)) ==&gt; #t
(eqv? (gen-loser) (gen-loser))
==&gt; unspecified
(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
(g (lambda () (if (eqv? f g) 'both 'g))))
(eqv? f g))
==&gt; unspecified
(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
(g (lambda () (if (eqv? f g) 'g 'both))))
(eqv? f g))
==&gt; #f
Since it is an error to modify constant objects (those returned
by literal expressions), implementations may share
structure between constants where appropriate. Thus the
value of eqv? on constants is sometimes implementationdependent.
(eqv? '(a) '(a)) ==&gt; unspecified
(eqv? "a" "a") ==&gt; unspecified
(eqv? '(b) (cdr '(a b))) ==&gt; unspecified
(let ((x '(a)))
(eqv? x x)) ==&gt; #t
The above definition of eqv? allows implementations latitude
in their treatment of procedures and literals: implementations
may either detect or fail to detect that two procedures
or two literals are equivalent to each other, and can
decide whether or not to merge representations of equivalent
objects by using the same pointer or bit pattern to
represent both.
Note: If inexact numbers are represented as IEEE binary

oating-point numbers, then an implementation of eqv? that
simply compares equal-sized inexact numbers for bitwise equal-
ity is correct by the above definition.
(eq? obj1 obj2) procedure
The eq? procedure is similar to eqv? except that in some
cases it is capable of discerning distinctions finer than those
detectable by eqv?. It must always return #f when eqv?
also would, but may return #f in some cases where eqv?
would return #t.
On symbols, booleans, the empty list, pairs, and records,
and also on non-empty strings, vectors, and bytevectors,
eq? and eqv? are guaranteed to have the same behavior.
On procedures, eq? must return true if the arguments' location
tags are equal. On numbers and characters, eq?'s
behavior is implementation-dependent, but it will always
return either true or false. On empty strings, empty vectors,
and empty bytevectors, eq? may also behave differently 
from eqv?.

(eq? 'a 'a) ==&gt; #t
(eq? '(a) '(a)) ==&gt; unspecified
(eq? (list 'a) (list 'a)) ==&gt; #f
(eq? "a" "a") ==&gt; unspecified
(eq? "" "") ==&gt; unspecified
(eq? '() '()) ==&gt; #t
(eq? 2 2) ==&gt; unspecified
(eq? #\A #\A)

{% include nav.html %}
<ADDRESS>
Justin
2013-11-14
</ADDRESS>
</BODY>
</HTML>
